<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Async Lab</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="01_motivation.html"><strong aria-hidden="true">1.</strong> Motivating Examples</a></li><li class="chapter-item expanded "><a href="02_future_trait.html"><strong aria-hidden="true">2.</strong> Future Trait</a></li><li class="chapter-item expanded "><a href="03_why_async_is_hard.html"><strong aria-hidden="true">3.</strong> Why async is hard</a></li><li class="chapter-item expanded "><a href="04_lab_diy_sleep_future.html"><strong aria-hidden="true">4.</strong> ðŸ”Ž Lab: DIY Sleep Future</a></li><li class="chapter-item expanded "><a href="05_lab_diy_sleep_future_solution.html"><strong aria-hidden="true">5.</strong> âœ… Lab Solution: DIY Sleep Future</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Async Lab</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="motivating-example"><a class="header" href="#motivating-example">Motivating example</a></h1>
<h2 id="blocking"><a class="header" href="#blocking">Blocking</a></h2>
<p>Consider we have an action that can be performed that takes a string and outputs a string.</p>
<p>Normally we would write this as:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn perform(input: String) -&gt; String {
    format!(&quot;Performed {}&quot;, input.as_str())
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="threading"><a class="header" href="#threading">Threading</a></h2>
<p>What if perform takes a while to compute and we have other operations we would like to perform?</p>
<p>One way to solve this is to use threading, and there are lots of ways to do this. For example
if your program has embarrassingly parallelizable work, <a href="https://crates.io/crates/rayon">rayon</a> may be a good fit.</p>
<p>A really simple way to this might be to simply spawn the work in a thread:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn perform_callback&lt;F&gt;(input: String, callback: F)
    where F: FnOnce(String) + Send + 'static
{
    std::thread::spawn(move || {
        callback(format!(&quot;Performed {}&quot;, input.as_str()))
    });
}
<span class="boring">}
</span></code></pre></pre>
<p>Or with rayon's threadpools:</p>
<pre><code class="language-rust ignore">fn perform_callback&lt;F&gt;(input: String, callback: F)
    where F: FnOnce(String) + Send + 'static
{
    rayon::spawn(move || {
        callback(format!(&quot;Performed {}&quot;, input.as_str()))
    });
}
</code></pre>
<h2 id="poll-based-io"><a class="header" href="#poll-based-io">Poll based IO</a></h2>
<p>There are downsides to the thread approach above. The biggest one however is that threads can be expensive.</p>
<p>In the rayon example we use a threadpool but what happens if we have hundreds of tasks or tasks can block execution of other tasks?</p>
<p>The solution to this problem really depends on the nature of the work we are performing. If the program is IO bound, and spends a significant time waiting for the network
or file IO, most operating systems already have apis to help alleviate this problem.</p>
<p>This is where apis like select and epoll are useful:</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Action {
    // The id for the action, useful for some of the more complicated examples
    id: usize,
    input: String
}

struct ActionSet {
    actions: Vec&lt;Action&gt;
}

impl ActionSet {
    fn new() -&gt; Self {
        ActionSet {
            actions: Vec::new()
        }
    }

    fn add(&amp;mut self, action: Action) {
        self.actions.push(action);
    }

    // With apis like epoll's epoll_wait() and select() all the pending IO operations
    // are monitor collectively through a single syscall that returns once something
    // interesting has happened
    fn poll(&amp;mut self)  -&gt; Option&lt;Vec&lt;(usize, String)&gt;&gt; {
        // Fake implemenation: just take a single action and complete it
        if let Some(action) = self.actions.pop() {
            let res = format!(&quot;Performed {}&quot;, action.input.as_str());
            return Some(vec![(action.id, res)])
        }

        None
    }
}

let action1 = Action {
    id: 1,
    input: &quot;First action&quot;.to_string()
};

let action2 = Action {
    id: 2,
    input: &quot;Second action&quot;.to_string()
};


// Poll/select style interfaces
let mut pending_actions = ActionSet::new();

// Add our actions
pending_actions.add(action1);
pending_actions.add(action2);

// Flow of the program is not centered around our event loop for better or worse
while let Some(completed_actions) = pending_actions.poll() {
    // Many actions may have completed so loop through all of them
    for (id, res) in completed_actions {
        println!(&quot;Poll result: {}&quot;, res);
    }
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="further-reading"><a class="header" href="#further-reading">Further reading</a></h2>
<h3 id="rust-async-book"><a class="header" href="#rust-async-book">Rust async book</a></h3>
<p>The <a href="https://rust-lang.github.io/async-book/">rust async book</a> is a decent resource for
rust async.</p>
<p>The <a href="https://rust-lang.github.io/async-book/01_getting_started/02_why_async.html">Why Async</a> chapter does a better job going over all the different competing models for concurrency.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-future-trait"><a class="header" href="#the-future-trait">The future trait</a></h1>
<h2 id="definition"><a class="header" href="#definition">Definition</a></h2>
<p>Futures in rust are simply types that implement the <code>std::future::Future</code> trait</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span><span class="boring">use std::task::{Poll, Context};
</span><span class="boring">use std::pin::Pin;
</span>
pub trait Future {
    type Output;
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context&lt;'_&gt;) -&gt; Poll&lt;Self::Output&gt;;
}
<span class="boring">}
</span></code></pre></pre>
<p>Beyond generating Futures for you when you use the async keyword most of the futures infrastructure in rust is actually implemented in the standard library and community maintained crates.</p>
<h2 id="lifecycle-from-the-executors-perspective"><a class="header" href="#lifecycle-from-the-executors-perspective">Lifecycle from the executor's perspective</a></h2>
<ol>
<li>Poll future</li>
<li>If Poll::Ready is returned we are done horray</li>
<li>If Poll::Pending we go off and do other work until the context's waker is called.</li>
</ol>
<pre><code class="language-rust ignore">loop {
    let result = future.poll(context);

    match result {
        Poll::Ready(val) =&gt; {
            return val;
        },
        Poll::Pending =&gt; {
            // In complex muultithreaded runtimes the executor may switch to another task until the waker gets called

        }
    }
}
</code></pre>
<h2 id="lifecycle-from-the-futures-perspective"><a class="header" href="#lifecycle-from-the-futures-perspective">Lifecycle from the futures perspective</a></h2>
<ol>
<li>Check if ready if so return Poll:Ready</li>
<li>If not save the waker and call it when we are finally ready</li>
</ol>
<div style="break-before: page; page-break-before: always;"></div><h1 id="why-async-is-hard"><a class="header" href="#why-async-is-hard">Why async is hard</a></h1>
<p>Sometimes rust async programming can be a breeze but other times it is quite difficult and requires knowing about many of the deeper more complicated parts of rust such nonelided lifetimes and Pin etc...</p>
<h2 id="pin"><a class="header" href="#pin">Pin</a></h2>
<p>Pin allows rust say that something will not be moved or dropped without having to pass a container such as <code>Box</code> or a <code>&amp;mut</code>. This means pointers to pinned data will be valid as long as the Pinned struct
lives.</p>
<p>This can be useful for self referential data such as Futures whose state machines may contain references to data already owned by the future itself. With Pin's added invariant
its possible for the compiler to generate futures that are more efficient and compact in memory. https://boats.gitlab.io/blog/post/2018-01-25-async-i-self-referential-structs/</p>
<p>TODO: Take some compiler generated futures and and show case their use of this?</p>
<h2 id="async-closures"><a class="header" href="#async-closures">Async closures</a></h2>
<p>Unlike the <code>async fn ()</code> syntax <code>async ||</code> is not support in rust stable rust yet (see <a href="https://github.com/rust-lang/rust/issues/62290">tracking issue issue 62290</a>), so to work around this we use closures that happen to produce futures <code>FnOnce() -&gt; Future</code> or <code>|| async { }</code>.</p>
<h3 id="fnonce"><a class="header" href="#fnonce">FnOnce</a></h3>
<p>This works reasonably well assuming the closure is <code>FnOnce</code> since even if we need to move something into our <code>async {}</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn run_it&lt;F, Fut&gt;(f: F)
    where F: FnOnce() -&gt; Fut, Fut: Future&lt;Output=()&gt;
{
    f().await
}

<span class="boring">async {
</span>let mut output = None;

run_it(|| async {
    output = Some(42);
}).await;
<span class="boring">};
</span><span class="boring">}
</span></code></pre></pre>
<h3 id="fnmut"><a class="header" href="#fnmut">FnMut</a></h3>
<p>However it does mean that we have two closures to deal with in actuality. The normal one <code>|...|</code> and closure implicity created with <code>async</code>.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn run_it&lt;F, Fut&gt;(mut f: F)
    where F: FnMut() -&gt; Fut, Fut: Future&lt;Output=()&gt;
{
    f().await;
    f().await
}

<span class="boring">async {
</span>

// The following now longer compiles
// let output = None;
// run_it(|| async {
//     output = Some(42);
// }).await;

<span class="boring">};
</span><span class="boring">}
</span></code></pre></pre>
<p>An easy fix like <code>.clone()</code> is to toss output into a mutex. This make it so output only needs to be a <code>&amp;Mutex&lt;Option&lt;i32&gt;&gt;</code> in the closure.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;

async fn run_it&lt;F, Fut&gt;(mut f: F)
    where F: FnMut() -&gt; Fut, Fut: Future&lt;Output=()&gt;
{
    f().await;
    f().await
}


<span class="boring">async {
</span>
let output: Option&lt;i32&gt; = None;

let output_mutex = std::sync::Mutex::new(output);

run_it(||
    async {
        let mut locked_output = output_mutex.lock().unwrap();
        *locked_output = Some(42);
    }).await;

<span class="boring">};
</span><span class="boring">}
</span></code></pre></pre>
<p>Locking can verbose and have performance gotchas adds extra complexity (when using locks its a good idea to think about if your code can deadlock).</p>
<p>With pin and some torturous lifetime generics and some changes to the interface we can convince the compiler that the <code>&amp;mut Option&lt;i32&gt;</code> will only live as long as future the closure
returns and allow said lifetime to vary in each closure invocation.</p>
<pre><pre class="playground"><code class="language-rust edition2018">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::future::Future;
use std::pin::Pin;

// Taking output as a pinned data makes it easier to get the lifetimes for output right.
// The pin lets us repeatidly give out non-overlapping &amp;mut Option&lt;i32&gt;'s which we need
// since f is called twice
async fn run_it&lt;F&gt;(mut output: Pin&lt;&amp;mut Option&lt;i32&gt;&gt;, mut f: F)
    // This is some tricker higher kinded lifetime magic. We want to say our closure for any lifetime 'a
    // can take a pinned `&amp;'a mut Option&lt;i32&gt;` and return a future that lives as long as that output
    // By using this quantifier it lets us plug in different lifetimes for 'a instead of it being fixed
    // This matters since we need the lifetimes of 'a to not overlap with each other
    //
    // Note that the return type is now `Pin&lt;Box&lt;dyn Future&lt;Output=()&gt; + 'a&gt;&gt;` this is a work around
    // so we can tell rust the future is Future&lt;Output=()&gt; + 'a also (the for syntax only applies to a single where clause)
    where for &lt;'a&gt; F: FnMut(Pin&lt;&amp;'a mut Option&lt;i32&gt;&gt;) -&gt; Pin&lt;Box&lt;dyn Future&lt;Output=()&gt; + 'a&gt;&gt;
{
    // lifetime for 'a will end once we await and then drop the future being output
    f(output.as_mut()).await;
    // This lets us grab another &amp;mut ref for output with another different lifetime for 'a
    f(output.as_mut()).await
}


<span class="boring">async {
</span>
let mut output = Box::pin(None);

run_it(output.as_mut(), |mut output|
    Box::pin(async {
        *output.get_mut() = Some(42);
    })).await;

<span class="boring">};
</span><span class="boring">}
</span></code></pre></pre>
<p>In general it pays to think carefully when introducing state to futures if you need to repeatedly call future generating closure. Since neither of the solutions are particularly clean.</p>
<p>TODO: Would <code>DerefMut&lt;Target=Option&lt;i32&gt;&gt;</code> work here also? Do we really need Pin?</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-diy-sleep-future"><a class="header" href="#lab-diy-sleep-future">Lab: DIY Sleep Future</a></h1>
<p>Challenge: Build a future sleeps for a specified duration.</p>
<p>Can you make it so it doesn't block?</p>
<p>The following is a good startin place, it uses the <a href="https://docs.rs/futures/0.3.21/futures/index.html#">futures</a> crate for a basic executor:</p>
<pre><code class="language-rust ignore">use futures::executor::block_on;
use futures::join;
use std::future::Future;
use std::task::Poll;
use std::time::{Duration, Instant};

struct SleepFuture {
    completion_time: Instant,
}

impl SleepFuture {
    fn new(duration: Duration) -&gt; Self {
        SleepFuture {
            completion_time: Instant::now() + duration,
        }
    }
}

impl Future for SleepFuture {
    type Output = ();

    fn poll(
        self: std::pin::Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut std::task::Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt; {
        // Remember to call waker.wake() when the future is ready
        let waker = cx.waker().clone();

        // If SleepFuture is Unpin we can simply grab a &amp;mut ref here
        let self_mut_ref = self.get_mut();

        todo!();
    }
}

fn main() {
    // Run future in a very simple executor that blocks
    block_on(async {
        let start = Instant::now();
        SleepFuture::new(Duration::from_secs(1)).await;
        println!(
            &quot;SleepFuture::new(Duration::from_secs(1)) slept for: {:?} (should be ~1sec)&quot;,
            Instant::now() - start
        );
    });

    block_on(async {
        let start = Instant::now();

        // Run two SleepFutures concurrently
        join!(
            SleepFuture::new(Duration::from_secs(1)),
            SleepFuture::new(Duration::from_millis(250))
        );

        println!(&quot;Racing futures slept for: {:?} (should be ~1sec)&quot;, Instant::now() - start);
    });
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="lab-solution-diy-sleep-future"><a class="header" href="#lab-solution-diy-sleep-future">Lab Solution: DIY Sleep Future</a></h1>
<p>There are probably many ways to go about implementing sleep. Here is a simple one that spawns a thread to handle the sleeping.</p>
<pre><code class="language-rust ignore">// ANCHOR: lab_pre
use futures::executor::block_on;
use futures::join;
use std::future::Future;
use std::task::Poll;
use std::time::{Duration, Instant};

struct SleepFuture {
    completion_time: Instant,
}

impl SleepFuture {
    fn new(duration: Duration) -&gt; Self {
        SleepFuture {
            completion_time: Instant::now() + duration,
        }
    }
}

impl Future for SleepFuture {
    type Output = ();

    fn poll(
        self: std::pin::Pin&lt;&amp;mut Self&gt;,
        cx: &amp;mut std::task::Context&lt;'_&gt;,
    ) -&gt; Poll&lt;Self::Output&gt; {
        // Remember to call waker.wake() when the future is ready
        let waker = cx.waker().clone();

        // If SleepFuture is Unpin we can simply grab a &amp;mut ref here
        let self_mut_ref = self.get_mut();

        // ANCHOR_END: lab_pre
        if self_mut_ref.completion_time &lt;= Instant::now() {
            return Poll::Ready(());
        }

        let duration = self_mut_ref.completion_time - Instant::now();

        std::thread::spawn(move || {
            std::thread::sleep(duration);
            waker.wake();
        });

        Poll::Pending
        // ANCHOR: lab_post
    }
}

fn main() {
    // Run future in a very simple executor that blocks
    block_on(async {
        let start = Instant::now();
        SleepFuture::new(Duration::from_secs(1)).await;
        println!(
            &quot;SleepFuture::new(Duration::from_secs(1)) slept for: {:?} (should be ~1sec)&quot;,
            Instant::now() - start
        );
    });

    block_on(async {
        let start = Instant::now();

        // Run two SleepFutures concurrently
        join!(
            SleepFuture::new(Duration::from_secs(1)),
            SleepFuture::new(Duration::from_millis(250))
        );

        println!(&quot;Racing futures slept for: {:?} (should be ~1sec)&quot;, Instant::now() - start);
    });
}
// ANCHOR_END: lab_post
</code></pre>
<p>A more complicated efficient version could for example use a priority queue and a single thread to schedule wakes for <code>SleepFutures</code>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
